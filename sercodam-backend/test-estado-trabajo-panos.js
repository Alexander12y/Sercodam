const axios = require('axios');
const knex = require('knex');
const knexfile = require('./knexfile');

// Database connection
const db = knex(knexfile.development);

// API configuration
const API_BASE = process.env.API_BASE_URL || 'http://localhost:4000/api/v1';

// Test data
const TEST_DATA = {
    cliente: 'Cliente Test Estados Trabajo',
    observaciones: 'Orden de prueba para verificar estados de trabajo de pa√±os',
    prioridad: 'alta',
    panos: [
        {
            // No especificar id_item - dejar que el sistema seleccione
            altura_req: 2.0,
            ancho_req: 2.5,
            umbral_sobrante_m2: 1.0
        }
    ]
};

// Store test results
const testResults = {
    orderId: null,
    jobId: null,
    panoId: null, // Se determinar√° din√°micamente
    estadosCapturados: []
};

// Helper function to capture pano state
async function capturarEstadoPano(descripcion) {
    console.log(`\nüìä ${descripcion}:`);
    
    const pano = await db('pano')
        .where('id_item', testResults.panoId)
        .select('id_item', 'largo_m', 'ancho_m', 'area_m2', 'estado_trabajo')
        .first();
    
    if (pano) {
        console.log(`   üßµ Pa√±o ID ${pano.id_item}: ${pano.largo_m}m x ${pano.ancho_m}m = ${pano.area_m2}m¬≤ - Estado: ${pano.estado_trabajo}`);
        
        testResults.estadosCapturados.push({
            descripcion,
            timestamp: new Date().toISOString(),
            ...pano
        });
    } else {
        console.log(`   ‚ùå Pa√±o ID ${testResults.panoId} no encontrado`);
    }
    
    return pano;
}

// Helper function to get order state
async function capturarEstadoOrden(descripcion) {
    if (!testResults.orderId) return null;
    
    const orden = await db('orden_produccion')
        .where('id_op', testResults.orderId)
        .select('id_op', 'numero_op', 'estado')
        .first();
    
    if (orden) {
        console.log(`   üìã Orden ${orden.numero_op}: ${orden.estado}`);
    }
    
    return orden;
}

// Helper function to get cut job state
async function capturarEstadoTrabajoCorte(descripcion) {
    if (!testResults.orderId) return null;
    
    const trabajos = await db('trabajo_corte')
        .where('id_op', testResults.orderId)
        .select('job_id', 'id_item', 'estado', 'altura_req', 'ancho_req');
    
    trabajos.forEach(trabajo => {
        console.log(`   ‚úÇÔ∏è Trabajo ${trabajo.job_id}: Item ${trabajo.id_item} - ${trabajo.estado} (${trabajo.altura_req}x${trabajo.ancho_req})`);
        if (trabajo.id_item === testResults.panoId) {
            testResults.jobId = trabajo.job_id;
        }
    });
    
    return trabajos;
}

// Helper function to login
async function login() {
    console.log('\nüîê Iniciando sesi√≥n...');
    
    try {
        const response = await axios.post(`${API_BASE}/auth/login`, {
            username: 'admin2',
            password: 'Admin123!'
        });
        
        if (response.data.success) {
            console.log('‚úÖ Login exitoso');
            return response.data.data.tokens.accessToken;
        } else {
            throw new Error('Login failed');
        }
    } catch (error) {
        console.error('‚ùå Error en login:', error.response?.data || error.message);
        throw error;
    }
}

// Helper function to create order
async function crearOrden(token) {
    console.log('\nüìù Creando orden de producci√≥n...');
    
    try {
        const response = await axios.post(`${API_BASE}/ordenes`, TEST_DATA, {
            headers: { Authorization: `Bearer ${token}` }
        });
        
        if (response.data.success) {
            testResults.orderId = response.data.data.id_op;
            console.log(`‚úÖ Orden creada exitosamente: ${response.data.data.numero_op} (ID: ${testResults.orderId})`);
            return response.data.data;
        } else {
            throw new Error('Order creation failed');
        }
    } catch (error) {
        console.error('‚ùå Error creando orden:', error.response?.data || error.message);
        throw error;
    }
}

// Helper function to approve order
async function aprobarOrden(token, orderId) {
    console.log('\n‚úÖ Aprobando orden...');
    
    try {
        const response = await axios.post(`${API_BASE}/ordenes/${orderId}/approve`, {}, {
            headers: { Authorization: `Bearer ${token}` }
        });
        
        if (response.data.success) {
            console.log('‚úÖ Orden aprobada exitosamente');
            return response.data;
        } else {
            throw new Error('Order approval failed');
        }
    } catch (error) {
        console.error('‚ùå Error aprobando orden:', error.response?.data || error.message);
        throw error;
    }
}

// Helper function to complete cut job
async function completarCorte(token, jobId) {
    console.log('\n‚úÇÔ∏è Completando trabajo de corte...');
    
    try {
        // Get cut plans first
        const plansResponse = await axios.get(`${API_BASE}/ordenes/cut-jobs/${jobId}/plans`, {
            headers: { Authorization: `Bearer ${token}` }
        });
        
        if (!plansResponse.data.success) {
            throw new Error('Failed to get cut plans');
        }
        
        const plans = plansResponse.data.data;
        console.log(`   üìã Planes de corte encontrados: ${plans.length}`);
        
        // Create actual cuts based on plans
        const actualPieces = plans.map(plan => ({
            seq: plan.seq,
            altura_real: plan.altura_plan,
            ancho_real: plan.ancho_plan
        }));
        
        console.log(`   ‚úÇÔ∏è Enviando ${actualPieces.length} cortes reales...`);
        
        const response = await axios.post(`${API_BASE}/ordenes/submit-actual-cuts`, {
            job_id: jobId,
            actual_pieces: actualPieces
        }, {
            headers: { Authorization: `Bearer ${token}` }
        });
        
        if (response.data.success) {
            console.log('‚úÖ Trabajo de corte completado exitosamente');
            return response.data;
        } else {
            throw new Error('Cut job completion failed');
        }
    } catch (error) {
        console.error('‚ùå Error completando trabajo de corte:', error.response?.data || error.message);
        throw error;
    }
}

// Helper function to find which pano the system will select
async function encontrarPanoQueSeUsara() {
    console.log('\nüîç Encontrando pa√±o que el sistema seleccionar√°...');
    
    const altura_req = TEST_DATA.panos[0].altura_req;
    const ancho_req = TEST_DATA.panos[0].ancho_req;
    
    // Usar la misma l√≥gica que panosController.findSuitablePanos
    const panos = await db('pano as p')
        .select('p.*', 'rp.tipo_red')
        .leftJoin('red_producto as rp', 'p.id_mcr', 'rp.id_mcr')
        .where('p.estado_trabajo', 'Libre')
        .whereRaw('(GREATEST(p.largo_m, p.ancho_m) >= ? AND LEAST(p.largo_m, p.ancho_m) >= ?)', [altura_req, ancho_req])
        .whereRaw('p.area_m2 >= 0') // min_area_threshold = 0
        .whereNotExists(function() {
            this.select('*')
                .from('trabajo_corte as tc')
                .join('orden_produccion as op', 'tc.id_op', 'op.id_op')
                .whereRaw('tc.id_item = p.id_item')
                .whereIn('op.estado', ['en_proceso', 'completada']);
        })
        .orderBy('p.area_m2', 'asc');
    
    if (panos.length > 0) {
        const panoSeleccionado = panos[0]; // El sistema selecciona el m√°s peque√±o
        testResults.panoId = panoSeleccionado.id_item;
        console.log(`   ‚úÖ Sistema usar√° pa√±o ID ${panoSeleccionado.id_item}: ${panoSeleccionado.largo_m}m x ${panoSeleccionado.ancho_m}m = ${panoSeleccionado.area_m2}m¬≤`);
        return panoSeleccionado;
    } else {
        console.log('   ‚ùå No se encontr√≥ pa√±o adecuado');
        return null;
    }
}

// Helper function to cleanup test data
async function limpiarDatosPrueba() {
    console.log('\nüßπ Limpiando datos de prueba...');
    
    try {
        if (testResults.orderId) {
            // Delete cut jobs and related data
            await db('real_corte_pieza').whereIn('job_id', function() {
                this.select('job_id').from('trabajo_corte').where('id_op', testResults.orderId);
            }).del();
            
            await db('plan_corte_pieza').whereIn('job_id', function() {
                this.select('job_id').from('trabajo_corte').where('id_op', testResults.orderId);
            }).del();
            
            await db('reporte_variacion').whereIn('job_id', function() {
                this.select('job_id').from('trabajo_corte').where('id_op', testResults.orderId);
            }).del();
            
            await db('trabajo_corte').where('id_op', testResults.orderId).del();
            
            // Delete order details
            await db('orden_produccion_detalle').where('id_op', testResults.orderId).del();
            await db('herramienta_ordenada').where('id_op', testResults.orderId).del();
            
            // Delete remnants and movements
            await db('panos_sobrantes').where('id_op', testResults.orderId).del();
            await db('movimiento_inventario').where('id_op', testResults.orderId).del();
            
            // Delete the order
            await db('orden_produccion').where('id_op', testResults.orderId).del();
            
            console.log(`‚úÖ Datos de prueba eliminados para orden ${testResults.orderId}`);
        }
        
    } catch (error) {
        console.error('‚ùå Error limpiando datos de prueba:', error.message);
    }
}

// Main test function
async function probarEstadosTrabajoPanos() {
    console.log('üöÄ Iniciando prueba de estados de trabajo de pa√±os...');
    console.log('=' .repeat(70));
    
    let token;
    
    try {
        // 1. Encontrar pa√±o que el sistema seleccionar√°
        const panoSeleccionado = await encontrarPanoQueSeUsara();
        if (!panoSeleccionado) {
            console.log('‚ùå No hay pa√±os disponibles para la prueba');
            return;
        }
        
        // 2. Estado inicial
        await capturarEstadoPano('ESTADO INICIAL DEL PA√ëO');
        
        // 3. Login
        token = await login();
        
        // 4. Crear orden
        await crearOrden(token);
        await capturarEstadoPano('DESPU√âS DE CREAR ORDEN');
        await capturarEstadoOrden('Estado de la orden');
        
        // 5. Aprobar orden
        await aprobarOrden(token, testResults.orderId);
        await capturarEstadoPano('DESPU√âS DE APROBAR ORDEN');
        await capturarEstadoOrden('Estado de la orden');
        await capturarEstadoTrabajoCorte('Trabajos de corte');
        
        // 6. Completar corte
        if (testResults.jobId) {
            await completarCorte(token, testResults.jobId);
            await capturarEstadoPano('DESPU√âS DE COMPLETAR CORTE');
            await capturarEstadoOrden('Estado de la orden');
            await capturarEstadoTrabajoCorte('Trabajos de corte');
        } else {
            console.log('‚ö†Ô∏è  No se encontr√≥ trabajo de corte para completar');
        }
        
        // 7. Generar reporte de estados
        console.log('\nüìä REPORTE DE CAMBIOS DE ESTADO:');
        console.log('=' .repeat(70));
        
        testResults.estadosCapturados.forEach((estado, index) => {
            const anterior = index > 0 ? testResults.estadosCapturados[index - 1] : null;
            const cambioEstado = anterior && anterior.estado_trabajo !== estado.estado_trabajo 
                ? ` (cambi√≥ de "${anterior.estado_trabajo}")` 
                : '';
            
            console.log(`${index + 1}. ${estado.descripcion}`);
            console.log(`   üìê Dimensiones: ${estado.largo_m}m x ${estado.ancho_m}m = ${estado.area_m2}m¬≤`);
            console.log(`   üè∑Ô∏è  Estado de trabajo: ${estado.estado_trabajo}${cambioEstado}`);
            console.log();
        });
        
        // 8. Verificar comportamiento esperado
        console.log('\n‚úÖ VERIFICACI√ìN DEL COMPORTAMIENTO ESPERADO:');
        console.log('=' .repeat(70));
        
        const estadoInicial = testResults.estadosCapturados.find(e => e.descripcion.includes('INICIAL'));
        const estadoDespuesCrear = testResults.estadosCapturados.find(e => e.descripcion.includes('CREAR ORDEN'));
        const estadoDespuesAprobar = testResults.estadosCapturados.find(e => e.descripcion.includes('APROBAR ORDEN'));
        const estadoDespuesCorte = testResults.estadosCapturados.find(e => e.descripcion.includes('COMPLETAR CORTE'));
        
        // Verificaciones
        const inicialLibre = estadoInicial?.estado_trabajo === 'Libre';
        console.log(`   üìã 1. Estado inicial "Libre": ${inicialLibre ? '‚úÖ CORRECTO' : '‚ùå INCORRECTO'}`);
        
        const mantieneDespuesCrear = estadoDespuesCrear?.estado_trabajo === estadoInicial?.estado_trabajo;
        console.log(`   üìã 2. Se mantiene despu√©s de crear orden: ${mantieneDespuesCrear ? '‚úÖ CORRECTO' : '‚ùå INCORRECTO'}`);
        
        const reservadoDespuesAprobar = estadoDespuesAprobar?.estado_trabajo === 'Reservado';
        console.log(`   üìã 3. "Reservado" despu√©s de aprobar: ${reservadoDespuesAprobar ? '‚úÖ CORRECTO' : '‚ùå INCORRECTO'}`);
        
        const enProgresoDespuesCorte = estadoDespuesCorte?.estado_trabajo === 'En progreso';
        console.log(`   üìã 4. "En progreso" despu√©s de completar corte: ${enProgresoDespuesCorte ? '‚úÖ CORRECTO' : '‚ùå INCORRECTO'}`);
        
        const areReducida = estadoDespuesCorte && estadoInicial && (estadoDespuesCorte.area_m2 < estadoInicial.area_m2);
        console.log(`   üìã 5. √Årea reducida despu√©s del corte: ${areReducida ? '‚úÖ CORRECTO' : '‚ùå INCORRECTO'}`);
        
        // Log detallado del √°rea para debug
        if (estadoInicial && estadoDespuesCorte) {
            const reduccion = estadoInicial.area_m2 - estadoDespuesCorte.area_m2;
            console.log(`      üí° √Årea inicial: ${estadoInicial.area_m2}m¬≤, final: ${estadoDespuesCorte.area_m2}m¬≤, reducci√≥n: ${reduccion.toFixed(3)}m¬≤`);
            console.log(`      üîç Comparaci√≥n: ${estadoDespuesCorte.area_m2} < ${estadoInicial.area_m2} = ${estadoDespuesCorte.area_m2 < estadoInicial.area_m2}`);
        }
        
        // Resumen final
        const todasCorrectas = inicialLibre && mantieneDespuesCrear && reservadoDespuesAprobar && enProgresoDespuesCorte && areReducida;
        
        console.log('\nüéØ RESULTADO FINAL:');
        console.log(`   ${todasCorrectas ? 'üéâ TODAS LAS VERIFICACIONES PASARON' : '‚ö†Ô∏è  ALGUNAS VERIFICACIONES FALLARON'}`);
        
        if (todasCorrectas) {
            console.log('   ‚úÖ El flujo de estados de trabajo funciona correctamente');
        } else {
            console.log('   ‚ùå Hay problemas en el flujo de estados de trabajo');
        }
        
    } catch (error) {
        console.error('\n‚ùå ERROR EN LA PRUEBA:', error.message);
        console.error(error.stack);
    } finally {
        // Cleanup
        await limpiarDatosPrueba();
        
        // Close database connection
        await db.destroy();
        
        console.log('\nüîö Prueba finalizada y conexi√≥n cerrada');
    }
}

// Run the test
if (require.main === module) {
    probarEstadosTrabajoPanos().catch(console.error);
}

module.exports = { probarEstadosTrabajoPanos }; 